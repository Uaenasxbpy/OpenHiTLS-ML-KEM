### 第一部分：这篇论文做了什么？

这篇论文的核心贡献在于：**它在没有修改源代码的情况下，形式化验证了被广泛使用的、高度优化的遗留加密代码（AWS-LC 库中的 AES-256-GCM 和 SHA-384）。** 


1. **验证对象是生产级代码：** 这一项目没有选择验证为了形式化证明而重写的代码（如 EverCrypt），而是直接验证了 AWS LibCrypto（源自 Google BoringSSL）中的代码 。这些代码混合使用了 **C 语言** 和为了性能高度优化的 **x86 汇编** 。

2. **验证了混合语言实现 (C + x86)：** 研究团队扩展了 SAW 的能力，使其不仅能处理 C 代码（通过 LLVM），还能通过 Macaw 工具反编译二进制文件来符号执行 x86 汇编代码 。这使得他们能够验证 C 函数调用汇编函数（反之亦然）的复杂场景 。

3. **开发了验证重写 (Verified Rewrites) 技术：** 为了解决高度优化的代码（例如位运算技巧）与高层数学规范（Cryptol）之间差异过大、导致求解器无法自动化证明的问题，他们引入了一套重写规则系统 。这允许验证者手动编写“引理”来辅助求解器化简复杂的数学项 。

4. **模块化验证策略：** 他们采用自底向上的方法，先验证底层函数，再在上层函数验证中使用底层函数的规范进行“覆盖” (Override) 。



---

### 第二部分：对验证 KEM (ML-KEM/Kyber) 的具体启示

KEM 算法（特别是基于格的 Kyber）通常包含复杂的数学结构（多项式环、模运算、NTT）以及针对速度优化的汇编代码。这篇论文的方法论能帮 解决以下四个关键痛点：

#### 1.可以直接验证 Kyber 的 AVX2 汇编代码，而无需将其重写为 C
Kyber 的高性能实现通常包含大量的 AVX2 汇编代码。

* **论文经验：** 论文中通过 Macaw 将 x86 二进制提升为 SAW 的中间表示 (Crucible)，并证明其符合 Cryptol 规范 。他们甚至验证了 SHA-384 的 AVX 实现 。

* **建议：** 不要因为代码是汇编就跳过或重写。 可以利用 SAW 的 `crucible_llvm_verify_x86` 功能，直接加载编译好的对象文件（`.o`），对其中的汇编函数进行符号执行。这保证了验证的是最终真正运行的指令。

#### 2.利用重写规则解决数学优化带来的求解器超时问题

Kyber 代码中使用了 Montgomery 约减和 Barrett 约减，这些优化的 C 代码与 Cryptol 中的标准数学定义 `(a * b) % q` 差异巨大，SMT 求解器（如 Z3/Yices）很难自动推导出它们是等价的。

* **论文经验：** 论文作者在验证 SHA-384 时遇到了类似问题：规范使用的是标准位移，而实现代码使用了基于性能优化的复杂位操作组合 。为了解决这个问题，他们编写了 `Sigma0_thm` 这样的重写规则，告诉求解器如何将复杂的实现代码转换为简洁的规范形式 。

* **建议：** 在 SAW 中验证 NTT 或多项式乘法遇到求解器卡死时，不要干等。 需要编写 SAW-script 重写规则。 需要证明 `montgomery_reduce(a)` 在数学上等价于 `(a * R^-1) % q`。将这些作为“定理”加入到证明策略中，能大幅提升自动化验证的成功率。

#### 3.严格的分层覆盖策略
KEM 算法调用链很深（`crypto_kem_enc` -> `indcpa_enc` -> `poly_ntt` -> `ntt_layer`）。如果试图一次性展开所有函数进行验证，内存和时间开销会爆炸。

* **论文经验：** 论文明确指出，AES 和 SHA 函数太大，无法整体进行符号执行 。他们使用了“Overrides”机制：一旦证明了某个底层函数符合规范，在上层函数的证明中就直接用 Cryptol 规范替换该函数的实际执行 。

* **建议：**
* **Phase 1:** 先验证 `keccak`、`ntt`、`poly_reduce` 等独立的小函数。
* **Phase 2:** 在验证 `indcpa_enc` 时，不要让 SAW 进入 `ntt` 函数内部。使用 `crucible_llvm_unsafe_assume_spec` 或标准的 override 机制，让 SAW 相信 `ntt` 调用的结果就是 Cryptol 中 `ntt` 函数的输出。这能将问题的复杂度从指数级降低到线性级。

#### 4.先证明内存安全，再证明功能正确，分两步走

* **论文经验：** 论文作者通常在编写完整的 Cryptol 功能规范之前，先验证代码的内存安全性（没有越界读写） 。SAW 的符号执行在没有完整功能规范的情况下，就可以证明代码不存在未定义行为 。

* **建议：** 在数学公式是否匹配之前，先写一个只包含 `crucible_alloc` 和 `crucible_points_to` 的简单规范 。运行 SAW 检查是否存在数组越界。这能快速排除 Kyber 实现中常见的缓冲区溢出错误，将由于 Bug 导致的证明失败和由于数学复杂性导致的证明失败区分开来 。

---

### 验证重写规则到底是什么：

##### 1. 它是数学翻译，不是修改规则

在 Cryptol 规范里，定义通常是为了**可读性**和**数学准确性**写的；而在 C/汇编代码里，实现是为了**速度**写的。两者长得完全不一样。

* **规范 (Cryptol):** 写的是 `x >>> 28`（循环右移 28 位）。
* **实现 (x86/C):** 实际上做的是一系列复杂的位运算组合，例如 `(x << (64-28)) | (x >> 28)[cite_start]`，或者像论文中提到的那样，为了性能把几个不同的移位操作混合在一起处理 。

**重写规则的作用：**告诉SAW：虽然代码里写的是那一堆乱七八糟的位运算，但它在数学上**就等于** `x >>> 28`。”
##### 2. 为什么叫Verified(经过验证的)？
这是最重要的一点。不仅仅是告诉工具它们相等，SAW 会**先强制证明**这个重写规则本身是成立的 。
* **步骤 A (定义定理):** 写下一个规则：`Complex_Assembly_Op(x) == Simple_Spec_Op(x)` 。
* **步骤 B (验证定理):** SAW 调用求解器，遍历所有可能的输入，确认这个等式**永远为真** 。
* **步骤 C (应用规则):** 只有步骤 B 成功了，SAW 才会把这个规则存入知识库。在后续验证庞大的主程序时，每当遇到 `Complex_Assembly_Op`，它就会自动将其替换为 `Simple_Spec_Op`，从而简化计算 。

##### 3. 对你验证 KEM (Kyber) 的具体意义
在 KEM 算法中，这实际上就是处理**模运算优化**的神器。
* **场景：** Kyber 的规范里是简单的模运算 `c = (a * b) % q`。
* **代码：** 代码里用的是 **Montgomery Reduction**（蒙哥马利约减）或 **Barrett Reduction**，这些函数里全是位移、掩码和乘法，完全没有 `%` 符号。
* **如果不使重写规则：** 求解器会试图去分析那几十行位运算代码，最后发现太复杂，直接超时（Time out）或这就卡死 。
* **使用重写规则：** 定义一个规则：`montgomery_reduce(a) == (a * R_inv) % q`。SAW 验证这个规则通过后，就会把代码里所有复杂的蒙哥马利函数调用，在逻辑层面上替换成简单的 `(a * R_inv) % q`。这样，最终的代码就变得和规范长得一样了，证明就能通过。


