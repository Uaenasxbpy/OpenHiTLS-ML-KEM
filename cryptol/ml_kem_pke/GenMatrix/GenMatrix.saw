// enable_experimental;

// // 1. 加载资源
// import "GenMatrix.cry" as Model;
// mod <- llvm_load_module "GenMatrix.bc";

// // 2. 辅助函数

// let ptr_to_fresh_readonly name type = do {
//     x <- llvm_fresh_var name type;
//     p <- llvm_alloc_readonly type;
//     llvm_points_to p (llvm_term x);
//     return (p, x);
// };

// // 3. Mock Specs

// let HashFuncXOF_spec = do {
//     // 明确 libCtx 是 i8*
//     libCtx <- llvm_fresh_pointer (llvm_int 8);
    
//     (in_ptr, in_val) <- ptr_to_fresh_readonly "in" (llvm_array 34 (llvm_int 8));
//     let inLen = 34;
    
//     out_ptr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
//     let outLen = 1000;

//     llvm_execute_func [
//         libCtx, 
//         in_ptr, 
//         llvm_term {{ `inLen : [32] }}, 
//         out_ptr, 
//         llvm_term {{ `outLen : [32] }}
//     ];

//     llvm_points_to out_ptr (llvm_term {{ 
//         take`{1000} (Model::AbstractHash in_val) 
//     }});

//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// let Parse_spec = do {
//     polyNtt_ptr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    
//     (arrayB_ptr, arrayB_val) <- ptr_to_fresh_readonly "arrayB" (llvm_array 1000 (llvm_int 8));
//     let arrayLen = 1000;
//     let n = 256;

//     llvm_execute_func [
//         polyNtt_ptr, 
//         arrayB_ptr, 
//         llvm_term {{ `arrayLen : [32] }}, 
//         llvm_term {{ `n : [32] }}
//     ];

//     llvm_points_to polyNtt_ptr (llvm_term {{ 
//         [ fromInteger (fromZ c) : [16] 
//         | c <- Model::SpecParse arrayB_val 
//         ] 
//     }});

//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// // 4. GenMatrix 核心验证

// let GenMatrix_spec = do {
//     let k = 2;
    
//     // 1. Context
//     info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
//     llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ `k : [8] }} ]);

//     ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
    
//     // 使用 dummy 内存避免 void* 类型歧义
//     dummy_libctx <- llvm_alloc (llvm_int 8);
//     llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, dummy_libctx ]);

//     // 2. Digest
//     (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

//     // 3. isEnc
//     isEnc <- llvm_fresh_var "isEnc" (llvm_int 8);

//     // 4. Matrix Pointer Array (堆栈上的指针数组)
//     // 策略：我们不验证矩阵里的数据是否正确（因为 SAW 处理指针的指针很麻烦）
//     // 我们只验证 GenMatrix 的【控制流】：循环是否正确，Mock 是否被调用。
//     // 我们初始化一个由 NULL 组成的指针数组。
//     // 这样，当 GenMatrix 读取 matrix_ptr[i][j] 时，会读到 NULL。
//     // 然后调用 Parse(NULL, ...)。
//     // 我们的 Parse_spec 会捕获这次调用。只要 Parse_spec 不检查输入指针是否为 NULL，这就没问题。
    
//     matrix_ptr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
    
//     let null_p = llvm_null;
//     let row_null = llvm_array_value [null_p, null_p, null_p, null_p];
//     let matrix_val_null = llvm_array_value [row_null, row_null, row_null, row_null];
    
//     llvm_points_to matrix_ptr matrix_val_null;

//     // --- Execute ---
//     llvm_execute_func [
//         ctx_ptr,
//         digest_ptr,
//         matrix_ptr,
//         llvm_term isEnc
//     ];

//     // --- Verify ---
//     // 这是最后一行，必须是 Action
//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// // 5. Execution

// print "1. 注册 Mock 规格...";
// hash_ov <- llvm_unsafe_assume_spec mod "HashFuncXOF" HashFuncXOF_spec;
// parse_ov <- llvm_unsafe_assume_spec mod "Parse" Parse_spec;

// print "2. 开始验证 GenMatrix...";
// llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec z3;


enable_experimental;
enable_deprecated;

import "GenMatrix.cry" as Model;
mod <- llvm_load_module "GenMatrix.bc";

// ------------------ helpers ------------------
let ptr_to_fresh_readonly name ty = do {
  x <- llvm_fresh_var name ty;
  p <- llvm_alloc_readonly ty;
  llvm_points_to p (llvm_term x);
  return (p, x);
};

// ------------------ Override: HashFuncXOF ------------------
// int32_t HashFuncXOF(void *libCtx, const uint8_t *in, uint32_t inLen,
//                     uint8_t *out, uint32_t outLen)
let HashFuncXOF_spec = do {
  libCtx <- llvm_fresh_pointer (llvm_int 8);

  (in_ptr, in_val) <- ptr_to_fresh_readonly "in" (llvm_array 34 (llvm_int 8));

  out_arr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
  let out_ptr = llvm_cast_pointer out_arr (llvm_pointer (llvm_int 8)); // ✅ 用 let

  llvm_execute_func [
    libCtx,
    in_ptr,
    llvm_term {{ 34 : [32] }},
    out_ptr,
    llvm_term {{ 1000 : [32] }}
  ];

  llvm_points_to out_arr (llvm_term {{ Model::AbstractHashOut in_val }});
  llvm_return (llvm_term {{ 0 : [32] }});
};

// ------------------ Override: Parse ------------------
// int32_t Parse(uint16_t *polyNtt, uint8_t *arrayB, uint32_t arrayLen, uint32_t n)
let Parse_spec = do {
  poly_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  let poly_ptr = llvm_cast_pointer poly_arr (llvm_pointer (llvm_int 16)); // ✅ 用 let

  // 输入 arrayB（我们用符号数组描述其内容）
  array_arr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
  let array_ptr = llvm_cast_pointer array_arr (llvm_pointer (llvm_int 8)); // ✅ 用 let
  array_val <- llvm_fresh_var "arrayB" (llvm_array 1000 (llvm_int 8));
  llvm_points_to array_arr (llvm_term array_val);

  llvm_execute_func [
    poly_ptr,
    array_ptr,
    llvm_term {{ 1000 : [32] }},
    llvm_term {{ 256  : [32] }}
  ];

  // 保持输入内存仍然是 array_val（防止 override 里丢失内存描述）
  llvm_points_to array_arr (llvm_term array_val);

  // 输出等于 ParseHappy(take 384 bytes)
  llvm_points_to poly_arr (llvm_term {{ Model::ParseHappy (take`{384} array_val) }});

  llvm_return (llvm_term {{ 0 : [32] }});
};

// ------------------ GenMatrix spec: isEnc = False ------------------
let GenMatrix_spec_false = do {
  // ctx->info->k = 2, ctx->libCtx = null
  info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
  llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ 2 : [8] }} ]);

  ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
  llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, llvm_null ]);

  // digest
  (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

  // 4 个输出 buffer
  buf00_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf01_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf10_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf11_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));

  let p_i16 = llvm_pointer (llvm_int 16);
  let buf00_ptr = llvm_cast_pointer buf00_arr p_i16;
  let buf01_ptr = llvm_cast_pointer buf01_arr p_i16;
  let buf10_ptr = llvm_cast_pointer buf10_arr p_i16;
  let buf11_ptr = llvm_cast_pointer buf11_arr p_i16;

  // polyMatrix: [4][4] of i16*
  let nullp = llvm_null;
  let row0 = llvm_array_value [ buf00_ptr, buf01_ptr, nullp, nullp ];
  let row1 = llvm_array_value [ buf10_ptr, buf11_ptr, nullp, nullp ];
  let row2 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];
  let row3 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];

  matrix_arr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
  llvm_points_to matrix_arr (llvm_array_value [ row0, row1, row2, row3 ]);

  let matrix_arg = llvm_cast_pointer matrix_arr
    (llvm_pointer (llvm_array 4 (llvm_pointer (llvm_int 16))));

  // isEnc = false (i1)
  llvm_execute_func [
    ctx_ptr,
    digest_ptr,
    matrix_arg,
    llvm_term {{ 0 : [1] }}
  ];

  llvm_return (llvm_term {{ 0 : [32] }});

  let expected = {{ Model::GenMatrixToy digest_val False }};

  llvm_points_to buf00_arr (llvm_term {{ expected @ 0 @ 0 }});
  llvm_points_to buf01_arr (llvm_term {{ expected @ 0 @ 1 }});
  llvm_points_to buf10_arr (llvm_term {{ expected @ 1 @ 0 }});
  llvm_points_to buf11_arr (llvm_term {{ expected @ 1 @ 1 }});
};

// ------------------ GenMatrix spec: isEnc = True ------------------
let GenMatrix_spec_true = do {
  info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
  llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ 2 : [8] }} ]);

  ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
  llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, llvm_null ]);

  (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

  buf00_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf01_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf10_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
  buf11_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));

  let p_i16 = llvm_pointer (llvm_int 16);
  let buf00_ptr = llvm_cast_pointer buf00_arr p_i16;
  let buf01_ptr = llvm_cast_pointer buf01_arr p_i16;
  let buf10_ptr = llvm_cast_pointer buf10_arr p_i16;
  let buf11_ptr = llvm_cast_pointer buf11_arr p_i16;

  let nullp = llvm_null;
  let row0 = llvm_array_value [ buf00_ptr, buf01_ptr, nullp, nullp ];
  let row1 = llvm_array_value [ buf10_ptr, buf11_ptr, nullp, nullp ];
  let row2 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];
  let row3 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];

  matrix_arr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
  llvm_points_to matrix_arr (llvm_array_value [ row0, row1, row2, row3 ]);

  let matrix_arg = llvm_cast_pointer matrix_arr
    (llvm_pointer (llvm_array 4 (llvm_pointer (llvm_int 16))));

  // isEnc = true (i1)
  llvm_execute_func [
    ctx_ptr,
    digest_ptr,
    matrix_arg,
    llvm_term {{ 1 : [1] }}
  ];

  llvm_return (llvm_term {{ 0 : [32] }});

  let expected = {{ Model::GenMatrixToy digest_val True }};

  llvm_points_to buf00_arr (llvm_term {{ expected @ 0 @ 0 }});
  llvm_points_to buf01_arr (llvm_term {{ expected @ 0 @ 1 }});
  llvm_points_to buf10_arr (llvm_term {{ expected @ 1 @ 0 }});
  llvm_points_to buf11_arr (llvm_term {{ expected @ 1 @ 1 }});
};

// ------------------ Run ------------------
print "Registering overrides...";
hash_ov <- llvm_unsafe_assume_spec mod "HashFuncXOF" HashFuncXOF_spec;
parse_ov <- llvm_unsafe_assume_spec mod "Parse"       Parse_spec;

print "Verifying GenMatrix with isEnc=False...";
llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec_false z3;

print "Verifying GenMatrix with isEnc=True...";
llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec_true  z3;
