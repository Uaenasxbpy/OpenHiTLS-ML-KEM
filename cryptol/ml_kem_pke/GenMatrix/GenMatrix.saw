// enable_experimental;

// // 1. 加载资源
// import "GenMatrix.cry" as Model;
// mod <- llvm_load_module "GenMatrix.bc";

// // 2. 辅助函数

// let ptr_to_fresh_readonly name type = do {
//     x <- llvm_fresh_var name type;
//     p <- llvm_alloc_readonly type;
//     llvm_points_to p (llvm_term x);
//     return (p, x);
// };

// // 3. Mock Specs

// let HashFuncXOF_spec = do {
//     // 明确 libCtx 是 i8*
//     libCtx <- llvm_fresh_pointer (llvm_int 8);
    
//     (in_ptr, in_val) <- ptr_to_fresh_readonly "in" (llvm_array 34 (llvm_int 8));
//     let inLen = 34;
    
//     out_ptr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
//     let outLen = 1000;

//     llvm_execute_func [
//         libCtx, 
//         in_ptr, 
//         llvm_term {{ `inLen : [32] }}, 
//         out_ptr, 
//         llvm_term {{ `outLen : [32] }}
//     ];

//     llvm_points_to out_ptr (llvm_term {{ 
//         take`{1000} (Model::AbstractHash in_val) 
//     }});

//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// let Parse_spec = do {
//     polyNtt_ptr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    
//     (arrayB_ptr, arrayB_val) <- ptr_to_fresh_readonly "arrayB" (llvm_array 1000 (llvm_int 8));
//     let arrayLen = 1000;
//     let n = 256;

//     llvm_execute_func [
//         polyNtt_ptr, 
//         arrayB_ptr, 
//         llvm_term {{ `arrayLen : [32] }}, 
//         llvm_term {{ `n : [32] }}
//     ];

//     llvm_points_to polyNtt_ptr (llvm_term {{ 
//         [ fromInteger (fromZ c) : [16] 
//         | c <- Model::SpecParse arrayB_val 
//         ] 
//     }});

//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// // 4. GenMatrix 核心验证

// let GenMatrix_spec = do {
//     let k = 2;
    
//     // 1. Context
//     info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
//     llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ `k : [8] }} ]);

//     ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
    
//     // 使用 dummy 内存避免 void* 类型歧义
//     dummy_libctx <- llvm_alloc (llvm_int 8);
//     llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, dummy_libctx ]);

//     // 2. Digest
//     (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

//     // 3. isEnc
//     isEnc <- llvm_fresh_var "isEnc" (llvm_int 8);

//     // 4. Matrix Pointer Array (堆栈上的指针数组)
//     // 策略：我们不验证矩阵里的数据是否正确（因为 SAW 处理指针的指针很麻烦）
//     // 我们只验证 GenMatrix 的【控制流】：循环是否正确，Mock 是否被调用。
//     // 我们初始化一个由 NULL 组成的指针数组。
//     // 这样，当 GenMatrix 读取 matrix_ptr[i][j] 时，会读到 NULL。
//     // 然后调用 Parse(NULL, ...)。
//     // 我们的 Parse_spec 会捕获这次调用。只要 Parse_spec 不检查输入指针是否为 NULL，这就没问题。
    
//     matrix_ptr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
    
//     let null_p = llvm_null;
//     let row_null = llvm_array_value [null_p, null_p, null_p, null_p];
//     let matrix_val_null = llvm_array_value [row_null, row_null, row_null, row_null];
    
//     llvm_points_to matrix_ptr matrix_val_null;

//     // --- Execute ---
//     llvm_execute_func [
//         ctx_ptr,
//         digest_ptr,
//         matrix_ptr,
//         llvm_term isEnc
//     ];

//     // --- Verify ---
//     // 这是最后一行，必须是 Action
//     llvm_return (llvm_term {{ 0 : [32] }});
// };

// // 5. Execution

// print "1. 注册 Mock 规格...";
// hash_ov <- llvm_unsafe_assume_spec mod "HashFuncXOF" HashFuncXOF_spec;
// parse_ov <- llvm_unsafe_assume_spec mod "Parse" Parse_spec;

// print "2. 开始验证 GenMatrix...";
// llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec z3;


enable_experimental;

import "GenMatrix.cry" as Model;
mod <- llvm_load_module "GenMatrix.bc";

// ------------------ helpers ------------------
let ptr_to_fresh_readonly name ty = do {
    x <- llvm_fresh_var name ty;
    p <- llvm_alloc_readonly ty;
    llvm_points_to p (llvm_term x);
    return (p, x);
};

// ------------------ Override: HashFuncXOF ------------------
let HashFuncXOF_spec = do {
    libCtx <- llvm_fresh_pointer (llvm_int 8);

    (in_ptr, in_val) <- ptr_to_fresh_readonly "in" (llvm_array 34 (llvm_int 8));

    // ✅ 修复 1: 直接使用 out_arr，不要 cast
    out_arr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
    
    llvm_execute_func [
        libCtx,
        in_ptr,
        llvm_term {{ 34 : [32] }},
        out_arr, // 直接传这个
        llvm_term {{ 1000 : [32] }}
    ];

    llvm_points_to out_arr (llvm_term {{ Model::AbstractHashOut in_val }});
    llvm_return (llvm_term {{ 0 : [32] }});
};

// ------------------ Override: Parse ------------------
let Parse_spec = do {
    // ✅ 修复 2: 直接使用 poly_arr，不要 cast
    poly_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    
    // ✅ 修复 3: 直接使用 array_arr，不要 cast
    array_arr <- llvm_alloc (llvm_array 1000 (llvm_int 8));
    array_val <- llvm_fresh_var "arrayB" (llvm_array 1000 (llvm_int 8));
    llvm_points_to array_arr (llvm_term array_val);

    llvm_execute_func [
        poly_arr, // 直接传
        array_arr, // 直接传
        llvm_term {{ 1000 : [32] }},
        llvm_term {{ 256  : [32] }}
    ];

    // 保持输入不变
    llvm_points_to array_arr (llvm_term array_val);

    // 输出契约
    llvm_points_to poly_arr (llvm_term {{ Model::ParseHappy (take`{384} array_val) }});

    llvm_return (llvm_term {{ 0 : [32] }});
};

// ------------------ GenMatrix spec: isEnc = False ------------------
let GenMatrix_spec_false = do {
    // 构造 Context
    info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
    llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ 2 : [8] }} ]);

    ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
    llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, llvm_null ]);

    // Digest
    (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

    // 4 个输出 buffer
    buf00_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf01_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf10_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf11_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));

    // ✅ 修复 4: 构造指针数组时，也尽量减少 cast，不过这里为了放入 array_value 可能需要 cast
    // 如果下面 matrix_arr 定义的是 pointer(i16)，那 buffer 应该是 pointer(i16)
    // 这里的 cast 是为了匹配 matrix_arr 的元素类型，通常是安全的
    let p_i16 = llvm_pointer (llvm_int 16);
    let buf00_ptr = llvm_cast_pointer buf00_arr p_i16;
    let buf01_ptr = llvm_cast_pointer buf01_arr p_i16;
    let buf10_ptr = llvm_cast_pointer buf10_arr p_i16;
    let buf11_ptr = llvm_cast_pointer buf11_arr p_i16;

    let nullp = llvm_null;
    let row0 = llvm_array_value [ buf00_ptr, buf01_ptr, nullp, nullp ];
    let row1 = llvm_array_value [ buf10_ptr, buf11_ptr, nullp, nullp ];
    let row2 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];
    let row3 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];

    matrix_arr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
    llvm_points_to matrix_arr (llvm_array_value [ row0, row1, row2, row3 ]);

    // ✅ 修复 5: matrix_arg 不需要 cast，直接传 array 指针即可
    // LLVM 会自动处理 [4 x [4 x i16*]]* -> i16*** 的匹配
    
    // ✅ 修复 6: isEnc 类型改为 [8] (兼容 C bool)
    llvm_execute_func [
        ctx_ptr,
        digest_ptr,
        matrix_arr, // 直接传
        llvm_term {{ 0 : [8] }} 
    ];

    llvm_return (llvm_term {{ 0 : [32] }});

    let expected = {{ Model::GenMatrixToy digest_val False }};

    llvm_points_to buf00_arr (llvm_term {{ expected @ 0 @ 0 }});
    llvm_points_to buf01_arr (llvm_term {{ expected @ 0 @ 1 }});
    llvm_points_to buf10_arr (llvm_term {{ expected @ 1 @ 0 }});
    llvm_points_to buf11_arr (llvm_term {{ expected @ 1 @ 1 }});
};

// ------------------ GenMatrix spec: isEnc = True ------------------
let GenMatrix_spec_true = do {
    info_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Info");
    llvm_points_to info_ptr (llvm_struct_value [ llvm_term {{ 2 : [8] }} ]);

    ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.CRYPT_MLKEM_Ctx");
    llvm_points_to ctx_ptr (llvm_struct_value [ info_ptr, llvm_null ]);

    (digest_ptr, digest_val) <- ptr_to_fresh_readonly "digest" (llvm_array 32 (llvm_int 8));

    buf00_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf01_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf10_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));
    buf11_arr <- llvm_alloc (llvm_array 256 (llvm_int 16));

    let p_i16 = llvm_pointer (llvm_int 16);
    let buf00_ptr = llvm_cast_pointer buf00_arr p_i16;
    let buf01_ptr = llvm_cast_pointer buf01_arr p_i16;
    let buf10_ptr = llvm_cast_pointer buf10_arr p_i16;
    let buf11_ptr = llvm_cast_pointer buf11_arr p_i16;

    let nullp = llvm_null;
    let row0 = llvm_array_value [ buf00_ptr, buf01_ptr, nullp, nullp ];
    let row1 = llvm_array_value [ buf10_ptr, buf11_ptr, nullp, nullp ];
    let row2 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];
    let row3 = llvm_array_value [ nullp,    nullp,    nullp, nullp ];

    matrix_arr <- llvm_alloc (llvm_array 4 (llvm_array 4 (llvm_pointer (llvm_int 16))));
    llvm_points_to matrix_arr (llvm_array_value [ row0, row1, row2, row3 ]);

    // ✅ 修复 7: isEnc = 1 (8-bit)
    llvm_execute_func [
        ctx_ptr,
        digest_ptr,
        matrix_arr, 
        llvm_term {{ 1 : [8] }}
    ];

    llvm_return (llvm_term {{ 0 : [32] }});

    let expected = {{ Model::GenMatrixToy digest_val True }};

    llvm_points_to buf00_arr (llvm_term {{ expected @ 0 @ 0 }});
    llvm_points_to buf01_arr (llvm_term {{ expected @ 0 @ 1 }});
    llvm_points_to buf10_arr (llvm_term {{ expected @ 1 @ 0 }});
    llvm_points_to buf11_arr (llvm_term {{ expected @ 1 @ 1 }});
};

// ------------------ Run ------------------
print "Registering overrides...";
hash_ov <- llvm_unsafe_assume_spec mod "HashFuncXOF" HashFuncXOF_spec;
parse_ov <- llvm_unsafe_assume_spec mod "Parse"       Parse_spec;

print "Verifying GenMatrix with isEnc=False...";
llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec_false z3;

print "Verifying GenMatrix with isEnc=True...";
llvm_verify mod "GenMatrix" [hash_ov, parse_ov] false GenMatrix_spec_true  z3;
