#### 1. 维度一：算法核心逻辑与错误处理验证

**（验证点：拒绝采样逻辑 + 数据不足时的报错逻辑）**

* **输入长度**：`InputLen = 12` (短输入)
* **目标数量**：`Target_N = 256` (大目标)


* **逻辑分析**： 12 字节理论上最多产生 8 个系数，远小于 256。因此，任务**注定失败**。

* **返回值**：C 代码必须返回 `-1` (ERROR)。
* **内存副作用**：虽然任务失败，但已处理的前几个字节必须被正确解析（遵循 12-bit 拼接规则），且不合格的数值（）必须被正确丢弃。
* **结论**：证明了 `Parse` 函数的位操作运算正确，拒绝采样（Rejection Sampling）逻辑正确，且在数据流耗尽时能安全退出并报错。

#### 2. 维度二：动态分支与功能完备性验证

**（验证点：成功/失败的临界判断能力）**

* **输入长度**：`InputLen = 12` (短输入)
* **目标数量**：`Target_N = 4` (小目标)

* **逻辑分析**：这是一个“临界状态”。12 字节可能产生8个系数（足够），也可能因为运气不好全被拒绝而少于 4 个（不足）。输入数据的不同导致结果在Success(0)和Error (-1)之间摇摆。

* 使用动态预言机。Cryptol根据输入计算预期状态。 证明C代码能够像Cryptol一样，根据数据质量判断是返回0还是-1。

* **结论**：证明了 `Parse` 函数的计数器逻辑 (`j`) 和循环终止条件在勉强够用的边缘情况下依然精准无误。

#### 3. 维度三：内存安全与防溢出验证

**（验证点：缓冲区溢出保护 + 截断逻辑）**

* **输入长度**：`InputLen = 24` (超长输入，过量供给)
* **目标数量**：`Target_N = 4` (小目标)

* **逻辑分析**：24 字节产生的有效系数几乎必然。如果不加控制，C代码可能会解析出8个系数并写入内存，导致逻辑越界。
* **SAW 验证目标**：

* **截断验证**：Cryptol 模型使用 `truncate_to_n` 模拟截断。SAW 验证 C 代码的内存中**只有前 4 个位置**有数据，第 5 个位置必须保持为初始值（0）。
* **返回值**：C 代码必须返回 `0`。


* **结论**：证明了 C 代码中的 `while(j < n)` 和 `if (... && j < n)` 检查是有效的。即使攻击者或调用者提供了过量的数据，函数也能严格遵守 `n` 的限制，**绝不越界写入**。

---

### 验证体系架构

为了便于理解，可以把这个体系抽象为一个统一的模型：

**核心资产 (Golden Model):**
一个通用的 **Cryptol (`Parse.cry`)** 模型，具备泛型输入 `{n}` 和截断预测功能 `predict_return_value_overflow`。

**总结：**
这三个脚本共同构成了一个**完备集**，证明了 `Parse` 函数在**数据不足**、**数据刚好**、**数据过量**三种情况下的行为均严格符合 ML-KEM 的数学定义，且无内存安全漏洞。

---
### 等价性
**why** :256个系数，至少需要384字节 => 状态空间为 2^(384 ✖ 8)。
* 路径 A：资源耗尽检查(parse.saw)
```c
if (i + 3 > arrayLen) { return ERROR; }
```
因为 12 字节填不满 256，循环必然会走到 i 耗尽的时刻。
* 路径 B：拒绝采样逻辑(parse.saw)
```c
if (d1 < MLKEM_Q) ...
if (d2 < MLKEM_Q ...)
```
* 路径 C：目标达成终止(parse2.saw)
当 j 增加到 4 时，while 条件 4 < 4 变为假，循环终止。
* 路径 D：边界溢出保护(parse3.saw)
```c
if (d2 < MLKEM_Q && j < n)
```
当 d1 填入了第 4 个数（j 变为 4），轮到 d2 时，虽然 d2 可能合格，但 j < n 失败，所以 d2 不能被写入。