// 1. 加载依赖和模块
enable_experimental;
import "BarrettReduction.cry";
import "ml_kem_poly.cry" as m;  // 明确导入模块 m

m <- llvm_load_module "ml_kem_poly.bc";  // 加载 .bc 文件

// 常量定义
let MLKEM_N = 256;
let MLKEM_QUARTER_N = 64;
let MLKEM_K_MAX = 4;
let llvm_int16 = llvm_int 16;
let llvm_int16_array_n = llvm_array MLKEM_N llvm_int16;
let llvm_int16_array_qn = llvm_array MLKEM_QUARTER_N llvm_int16;

// // 2. 验证 PolyReduce 函数
// let polyReduce_spec = do {
//   poly_ptr <- llvm_alloc llvm_int16_array_n;
//   poly_sym <- llvm_fresh_var "poly" llvm_int16_array_n;
//   llvm_points_to poly_ptr (llvm_term poly_sym);

//   llvm_execute_func [poly_ptr];

//   let expected = {{ m::polyReduce poly_sym }};  // 使用 m 命名空间来调用 polyReduce
//   llvm_points_to poly_ptr (llvm_term expected);
// };

// polyReduce_thm <- llvm_verify m "PolyReduce" [] false polyReduce_spec abc;
// print "PolyReduce 验证完成！";

// 3. 验证 BaseMulAdd 函数
let baseMulAdd_spec = do {
  polyH_ptr <- llvm_alloc (llvm_array 2 llvm_int16);
  polyH_init <- llvm_fresh_var "polyH_init" (llvm_array 2 llvm_int16);
  f0 <- llvm_fresh_var "f0" llvm_int16;
  f1 <- llvm_fresh_var "f1" llvm_int16;
  g0 <- llvm_fresh_var "g0" llvm_int16;
  g1 <- llvm_fresh_var "g1" llvm_int16;
  factor <- llvm_fresh_var "factor" llvm_int16;

  // --- 新增：添加先决条件 (Preconditions)
  // 限制输入在 Kyber 的合理范围内 ( -3329到3329，或者12-bit范围)
  llvm_precond {{ (f0 >$ -4096) /\ (f0 <$ 4096) }};
  llvm_precond {{ (f1 >$ -4096) /\ (f1 <$ 4096) }};
  llvm_precond {{ (g0 >$ -4096) /\ (g0 <$ 4096) }};
  llvm_precond {{ (g1 >$ -4096) /\ (g1 <$ 4096) }};


  llvm_points_to polyH_ptr (llvm_term polyH_init);
  llvm_execute_func [polyH_ptr, llvm_term f0, llvm_term f1, llvm_term g0, llvm_term g1, llvm_term factor];
  let expected = {{ m::baseMulAdd polyH_init f0 f1 g0 g1 factor }};  // 使用 m 命名空间来调用 baseMulAdd
  llvm_points_to polyH_ptr (llvm_term expected);
};

baseMulAdd_thm <- llvm_verify m "BaseMulAdd" [] false baseMulAdd_spec abc;
print "BaseMulAdd 验证完成！";

// 4. 验证 CircMulAdd 函数
let circMulAdd_spec = do {
  dest_ptr <- llvm_alloc llvm_int16_array_n;
  src1_ptr <- llvm_alloc llvm_int16_array_n;
  src2_ptr <- llvm_alloc llvm_int16_array_n;
  factor_ptr <- llvm_alloc llvm_int16_array_qn;

  dest_init <- llvm_fresh_var "dest_init" llvm_int16_array_n;
  src1 <- llvm_fresh_var "src1" llvm_int16_array_n;
  src2 <- llvm_fresh_var "src2" llvm_int16_array_n;
  factor <- llvm_fresh_var "factor" llvm_int16_array_qn;

  llvm_precond {{ all (\x -> (x >$ -4096) /\ (x <$ 4096)) src1 }};
  llvm_precond {{ all (\x -> (x >$ -4096) /\ (x <$ 4096)) src2 }};
  llvm_precond {{ all (\x -> (x >$ -4096) /\ (x <$ 4096)) factor }};

  llvm_points_to dest_ptr (llvm_term dest_init);
  llvm_points_to src1_ptr (llvm_term src1);
  llvm_points_to src2_ptr (llvm_term src2);
  llvm_points_to factor_ptr (llvm_term factor);

  llvm_execute_func [dest_ptr, src1_ptr, src2_ptr, factor_ptr];

  let expected = {{ m::circMulAdd dest_init src1 src2 factor }};  // 使用 m 命名空间来调用 circMulAdd
  llvm_points_to dest_ptr (llvm_term expected);
};

circMulAdd_thm <- llvm_verify m "CircMulAdd" [baseMulAdd_thm] false circMulAdd_spec abc;
print "CircMulAdd 验证完成！";

// =================配置参数=================
// let k = 3;             // ML-KEM-768
// let MLKEM_K_MAX = 4;   // 通常 C 代码中定义的常数，用于矩阵跨度
// let N = 256;
// let QN = 64;           // Quarter N

// =================辅助函数=================

// 1. 范围约束 Lambda (复用之前的逻辑)
let safe_bound = {{ \x -> (x >$ -4096) /\ (x <$ 4096) }};

// 2. 分配 PolyVec (int16_t **polyVec)
// 返回: (指针数组的基地址, 符号变量列表)
let setup_polyvec name k = do {
    // 分配存放指针的数组: int16_t *arr[k]
    ptr_arr <- llvm_alloc (llvm_array k llvm_ptr);
    
    // 遍历分配每一个多项式
    vars <- for [0 .. k-1] (\i -> do {
        // 分配具体数据 int16_t[N]
        data_ptr <- llvm_alloc llvm_int16_array_n;
        // 创建符号变量
        var <- llvm_fresh_var (str_concat name (show i)) llvm_int16_array_n;
        // 添加范围约束 (必须！否则 CircMulAdd 会失败)
        llvm_precond {{ all safe_bound var }};
        
        // 绑定数据
        llvm_points_to data_ptr (llvm_term var);
        // 让指针数组指向数据: arr[i] = data_ptr
        llvm_points_to (llvm_elem ptr_arr i) data_ptr;
        
        return var;
    });
    
    return (ptr_arr, vars);
};

// 3. 分配 Matrix (int16_t **matrix)
// 注意 C 代码中的 stride: matrix + i * MLKEM_K_MAX
let setup_matrix name k = do {
    // 分配足够大的指针数组: int16_t *mat[k * MLKEM_K_MAX]
    // 即使只用前 k 列，内存布局通常是固定的
    ptr_arr <- llvm_alloc (llvm_array (k * MLKEM_K_MAX) llvm_ptr);
    
    // 嵌套循环分配 k*k 个多项式
    // 返回的是 [k][k][MLKEM_N][16] 形式的 Cryptol 变量
    rows <- for [0 .. k-1] (\i -> do {
        cols <- for [0 .. k-1] (\j -> do {
            // 计算扁平化索引: i * MLKEM_K_MAX + j
            let idx = i * MLKEM_K_MAX + j;
            
            data_ptr <- llvm_alloc llvm_int16_array_n;
            var <- llvm_fresh_var (str_concat name (str_concat (show i) (show j))) llvm_int16_array_n;
            
            // 添加范围约束
            llvm_precond {{ all safe_bound var }};
            
            llvm_points_to data_ptr (llvm_term var);
            llvm_points_to (llvm_elem ptr_arr idx) data_ptr;
            
            return var;
        });
        return cols;
    });
    
    return (ptr_arr, rows);
};

// ==========================================
// 0. 基础配置与辅助函数
// ==========================================

// 定义安全范围约束 (避免 BaseMulAdd 契约失败)
// 必须使用有符号比较 >$ 和 <$
let safe_bound = {{ \x -> (x >$ -4096) /\ (x <$ 4096) }};

// 辅助：分配 PolyVec (int16_t *polyVec[k])
// 返回 (指针数组基地址, Cryptol符号变量列表)
let setup_polyvec name k = do {
    // 分配指针数组: int16_t *arr[k]
    ptr_arr <- llvm_alloc (llvm_array k llvm_ptr);
    
    // 遍历生成 k 个多项式
    vars <- for [0 .. k-1] (\i -> do {
        // 分配具体数据 int16_t[N]
        data_ptr <- llvm_alloc (llvm_array MLKEM_N llvm_int16);
        
        // 生成符号变量
        let var_name = str_concat name (str_concat "_" (show i));
        var <- llvm_fresh_var var_name (llvm_array MLKEM_N llvm_int16);
        
        // === 关键：添加范围约束 ===
        llvm_precond {{ all safe_bound var }};
        
        // 绑定数据与指针
        llvm_points_to data_ptr (llvm_term var);
        llvm_points_to (llvm_elem ptr_arr i) data_ptr;
        
        return var;
    });
    
    return (ptr_arr, vars);
};

// 辅助：分配 Matrix (int16_t *matrix[])
// 注意：C 代码中 stride 是 MLKEM_K_MAX (4)
let setup_matrix name k = do {
    // 即使 k=2, 内存也是按 stride=4 分配或访问的 (取决于调用者的内存池，但访问逻辑是固定的)
    // 我们分配足够的空间来容纳最大跨度: k * MLKEM_K_MAX
    let total_ptrs = eval_int {{ `k * `MLKEM_K_MAX }};
    ptr_arr <- llvm_alloc (llvm_array total_ptrs llvm_ptr);
    
    // 生成 k x k 的数据，但放在 stride 位置上
    rows <- for [0 .. k-1] (\i -> do {
        cols <- for [0 .. k-1] (\j -> do {
            // 计算扁平化索引: i * 4 + j
            let idx = eval_int {{ `i * `MLKEM_K_MAX + `j }};
            
            data_ptr <- llvm_alloc (llvm_array MLKEM_N llvm_int16);
            let var_name = str_concat name (str_concat "_" (str_concat (show i) (str_concat "_" (show j))));
            var <- llvm_fresh_var var_name (llvm_array MLKEM_N llvm_int16);
            
            // === 关键：添加范围约束 ===
            llvm_precond {{ all safe_bound var }};
            
            llvm_points_to data_ptr (llvm_term var);
            llvm_points_to (llvm_elem ptr_arr idx) data_ptr;
            
            return var;
        });
        return cols;
    });
    
    return (ptr_arr, rows);
};

// 辅助：设置 Factor 表
// 长度通常是 128 (MLKEM_N / 2)
let setup_factor = do {
    let len = 128; 
    ptr <- llvm_alloc (llvm_array len llvm_int16);
    val <- llvm_fresh_var "factor" (llvm_array len llvm_int16);
    // Factor 也必须在安全范围内
    llvm_precond {{ all safe_bound val }};
    llvm_points_to ptr (llvm_term val);
    return (ptr, val);
};

// ==========================================
// 1. MLKEM_MatrixMulAdd 验证生成器
// ==========================================
let mk_matrixMulAdd_spec k = do {
    (matrix_ptr, matrix_val) <- setup_matrix "matrix" k;
    (vec_ptr, vec_val) <- setup_polyvec "vec" k;
    (out_ptr, out_init_val) <- setup_polyvec "out" k;
    (factor_ptr, factor_val) <- setup_factor;

    // 指针偏移: factor + 64
    let factor_offset_ptr = llvm_ptr_add factor_ptr 64;

    llvm_execute_func [
        llvm_term {{ `k : [8] }},
        matrix_ptr,
        vec_ptr,
        out_ptr,
        factor_offset_ptr
    ];

    // Cryptol 期望 matrix 是 [k][k][N][16]
    // 我们的 setup_matrix 返回的 matrix_val 正是这个结构
    let expected = {{ m::matrixMulAdd matrix_val vec_val out_init_val factor_val }};

    // 验证输出
    for [0 .. k-1] (\i -> do {
        // 读取 out_ptr[i] 指向的地址
        elem_ptr <- llvm_load_elem out_ptr i; 
        llvm_points_to elem_ptr (llvm_term {{ expected @ i }});
    });
};

// ==========================================
// 2. MLKEM_TransposeMatrixMulAdd 验证生成器
// ==========================================
let mk_transposeMatrixMulAdd_spec k = do {
    (matrix_ptr, matrix_val) <- setup_matrix "matrix" k;
    (vec_ptr, vec_val) <- setup_polyvec "vec" k;
    (out_ptr, out_init_val) <- setup_polyvec "out" k;
    (factor_ptr, factor_val) <- setup_factor;

    let factor_offset_ptr = llvm_ptr_add factor_ptr 64;

    llvm_execute_func [
        llvm_term {{ `k : [8] }},
        matrix_ptr,
        vec_ptr,
        out_ptr,
        factor_offset_ptr
    ];

    let expected = {{ m::matrixTransposeMulAdd matrix_val vec_val out_init_val factor_val }};

    for [0 .. k-1] (\i -> do {
        elem_ptr <- llvm_load_elem out_ptr i;
        llvm_points_to elem_ptr (llvm_term {{ expected @ i }});
    });
};

// ==========================================
// 3. MLKEM_VectorInnerProductAdd 验证生成器
// ==========================================
let mk_vectorInnerProductAdd_spec k = do {
    (vec1_ptr, vec1_val) <- setup_polyvec "vec1" k;
    (vec2_ptr, vec2_val) <- setup_polyvec "vec2" k;
    
    // PolyOut 这里是单指针，不是指针数组
    out_ptr <- llvm_alloc (llvm_array MLKEM_N llvm_int16);
    out_init <- llvm_fresh_var "out_init" (llvm_array MLKEM_N llvm_int16);
    llvm_precond {{ all safe_bound out_init }};
    llvm_points_to out_ptr (llvm_term out_init);

    (factor_ptr, factor_val) <- setup_factor;
    let factor_offset_ptr = llvm_ptr_add factor_ptr 64;

    llvm_execute_func [
        llvm_term {{ `k : [8] }},
        vec1_ptr,
        vec2_ptr,
        out_ptr,
        factor_offset_ptr
    ];

    let expected = {{ m::vectorInnerProductAdd vec1_val vec2_val out_init factor_val }};
    llvm_points_to out_ptr (llvm_term expected);
};

// ==========================================
// 4. 执行验证循环 (k = 2, 3, 4)
// ==========================================

// 定义依赖定理列表 (确保这里包含了你的 circMulAdd 和 polyReduce 定理)
let method_overrides = [circMulAdd_thm, polyReduce_thm];

// 循环验证三个函数
for [2, 3, 4] (\k -> do {
    print (str_concat "Verifying Matrix functions for k=" (show k));
    
    // 验证 MatrixMulAdd
    llvm_verify m "MLKEM_MatrixMulAdd" method_overrides false (mk_matrixMulAdd_spec k) abc;
    
    // 验证 TransposeMatrixMulAdd
    llvm_verify m "MLKEM_TransposeMatrixMulAdd" method_overrides false (mk_transposeMatrixMulAdd_spec k) abc;
    
    // 验证 VectorInnerProductAdd
    llvm_verify m "MLKEM_VectorInnerProductAdd" method_overrides false (mk_vectorInnerProductAdd_spec k) abc;
    
    print (str_concat "Done k=" (show k));
});

// ==========================================
// 5. MLKEM_SamplePolyCBD 验证
// ==========================================
// 这个函数不依赖 k，而是依赖 eta (2 或 3)
// 我们可以分别验证两种情况

print "Verifying SamplePolyCBD...";

// Case Eta = 2
let cbd_eta2_spec = do {
    poly_ptr <- llvm_alloc (llvm_array MLKEM_N llvm_int16);
    
    // Eta=2, buf size = 2 * (N/4) = 128
    let len = 128;
    buf_ptr <- llvm_alloc (llvm_array len llvm_int8);
    buf_val <- llvm_fresh_var "buf_eta2" (llvm_array len llvm_int8);
    llvm_points_to buf_ptr (llvm_term buf_val);

    llvm_execute_func [
        poly_ptr,
        buf_ptr,
        llvm_term {{ 2 : [8] }}
    ];

    // 这里的 buf_val 长度是 128，Cryptol 那边 polyCBD_eta2 刚好接受 128
    let expected = {{ m::polyCBD_eta2 buf_val }};
    llvm_points_to poly_ptr (llvm_term expected);
};

llvm_verify m "MLKEM_SamplePolyCBD" [] false cbd_eta2_spec abc;

// Case Eta = 3
let cbd_eta3_spec = do {
    poly_ptr <- llvm_alloc (llvm_array MLKEM_N llvm_int16);
    
    // Eta=3, buf size = 3 * (N/4) = 192
    let len = 192;
    buf_ptr <- llvm_alloc (llvm_array len llvm_int8);
    buf_val <- llvm_fresh_var "buf_eta3" (llvm_array len llvm_int8);
    llvm_points_to buf_ptr (llvm_term buf_val);

    llvm_execute_func [
        poly_ptr,
        buf_ptr,
        llvm_term {{ 3 : [8] }}
    ];

    let expected = {{ m::polyCBD_eta3 buf_val }};
    llvm_points_to poly_ptr (llvm_term expected);
};

llvm_verify m "MLKEM_SamplePolyCBD" [] false cbd_eta3_spec abc;

print "所有验证完成！";
